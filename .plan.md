# Implementierungsplan: Speedcuben-Lernprogramm

## Übersicht
Ein Browser-basiertes Lernprogramm für Anfänger zum Speedcuben mit einfachen Perzeptionsaufgaben.

## Technologie-Stack
- **HTML5** für die Struktur
- **SVG** für die Würfeldarstellung
- **Vanilla JavaScript** für die Logik
- **CSS3** für das Styling
- **Deployment**: GitHub Pages (statische Dateien, kein Build-Prozess)

## Würfel-Darstellung (Isometrische Projektion)

### Geometrie
Die Würfelansicht zeigt 4 Seiten gleichzeitig:
- **Vorderseite (Front)**: Zentral, als Quadrat
- **Obere Seite (Top)**: Parallelogramm, nach hinten geneigt
- **Rechte Seite (Right)**: Parallelogramm, nach rechts versetzt
- **Linke Seite (Left)**: Parallelogramm, nach links versetzt

### SVG-Koordinaten-Berechnung
Für eine isometrisch-ähnliche Projektion verwenden wir:
- Winkel: ~30° für links/rechts-Perspektive
- Verkleinerungsfaktor: 0.5 für Tiefe

**Mathematik für ein 3x3 Raster:**
- Basis-Würfelgröße: z.B. 300px für die Vorderseite
- Einzelfeld-Größe: 100px (300/3)
- Abstand zwischen Feldern: 2px (für visuelle Trennung)

```
Koordinaten-Transformation:
Front (x,y,z=0):  SVG(x, y)
Top   (x,y,z):    SVG(x + z*cos(30°), y - z*sin(30°))
Right (x,y,z):    SVG(x + z*cos(30°), y + z*sin(30°))
Left  (x,y,z):    SVG(x - z*cos(30°), y + z*sin(30°))
```

### SVG-Struktur
```html
<svg id="cube" viewBox="0 0 800 800">
  <!-- Obere Seite (gezeichnet zuerst für korrekte Z-Order) -->
  <g id="top-face">
    <!-- 9 Felder als Polygone -->
  </g>

  <!-- Linke Seite -->
  <g id="left-face">
    <!-- 9 Felder als Polygone -->
  </g>

  <!-- Rechte Seite -->
  <g id="right-face">
    <!-- 9 Felder als Polygone -->
  </g>

  <!-- Vorderseite (zuletzt für Vordergrund) -->
  <g id="front-face">
    <!-- 9 Felder als Rechtecke -->
  </g>
</svg>
```

## Dateistruktur

```
cubelearner/
├── index.html          # Haupt-HTML-Datei
├── css/
│   └── style.css       # Styling
├── js/
│   ├── cube.js         # Würfel-Rendering-Logik
│   └── app.js          # Hauptanwendungslogik
└── README.md           # Dokumentation
```

## Implementierungsschritte

### 1. HTML-Grundgerüst (index.html)
- Semantisches HTML5-Dokument
- SVG-Container für den Würfel
- Responsive Meta-Tags
- Einbinden von CSS und JS

### 2. Würfel-Rendering-Modul (js/cube.js)
**Verantwortlichkeiten:**
- SVG-Felder generieren
- Koordinaten-Berechnungen für isometrische Projektion
- Farben für Felder setzen (initial: alle grau)
- API: `createCube(svgElement, size)`

**Funktionen:**
```javascript
// Hauptfunktion
function createCube(svgElement, faceSize = 300)

// Hilfsfunktionen
function createFrontFace(x, y, size)  // Rechtecke
function createTopFace(x, y, size)    // Parallelogramme
function createRightFace(x, y, size)  // Parallelogramme
function createLeftFace(x, y, size)   // Parallelogramme
function createSquare(x, y, size, color, dataAttributes)
function createParallelogram(points, color, dataAttributes)
```

**Datenstruktur für Felder:**
- Jedes Feld bekommt `data-*` Attribute:
  - `data-face`: "front", "top", "left", "right"
  - `data-row`: 0-2
  - `data-col`: 0-2
  - `data-color`: aktuell grau, später für Farben

### 3. Styling (css/style.css)
- Zentriertes Layout
- Responsive Design
- SVG-Styling (Rahmen, Schatten optional)
- Hover-Effekte für spätere Interaktivität vorbereiten
- Clean, minimalistisches Design

```css
:root {
  --cube-gray: #808080;
  --cube-border: #000000;
  --gap: 2px;
}

body {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
  margin: 0;
  background: #f5f5f5;
  font-family: Arial, sans-serif;
}

#cube-container {
  max-width: 90vmin;
}

.cube-field {
  fill: var(--cube-gray);
  stroke: var(--cube-border);
  stroke-width: 2;
}
```

### 4. Hauptlogik (js/app.js)
Initial sehr einfach:
```javascript
document.addEventListener('DOMContentLoaded', () => {
  const svgElement = document.getElementById('cube');
  createCube(svgElement, 300);
});
```

### 5. README.md
- Projektbeschreibung
- Verwendung
- Roadmap für zukünftige Features
- GitHub Pages Deployment-Anleitung

## Erweiterungsmöglichkeiten (für später)

1. **Perzeptionsaufgaben:**
   - Einzelne Felder einfärben
   - Muster erkennen lassen
   - Timer für Geschwindigkeit

2. **Farbschema:**
   - Standard Rubik's Cube Farben:
     - Front: Grün
     - Back: Blau
     - Top: Weiß
     - Bottom: Gelb
     - Left: Orange
     - Right: Rot

3. **Interaktivität:**
   - Felder anklicken
   - Patterns anzeigen
   - Fortschritt tracken

4. **Lern-Modi:**
   - Pattern Recognition
   - Color Matching
   - Position Memory
   - Algorithm Visualization

## Technische Details

### Isometrische Projektion - Berechnung
Für einen realistischen, aber nicht-perspektivischen Look:

```javascript
// Konstanten
const ANGLE = 30 * Math.PI / 180;  // 30 Grad in Radiant
const DEPTH_FACTOR = 0.866;         // cos(30°)
const HEIGHT_FACTOR = 0.5;          // sin(30°)

// Projektion für obere Seite (z nach hinten)
function projectTop(x, y, z) {
  return {
    x: x + z * DEPTH_FACTOR,
    y: y - z * HEIGHT_FACTOR
  };
}

// Projektion für rechte Seite (z nach rechts)
function projectRight(x, y, z) {
  return {
    x: x + z * DEPTH_FACTOR,
    y: y + z * HEIGHT_FACTOR
  };
}

// Projektion für linke Seite (z nach links)
function projectLeft(x, y, z) {
  return {
    x: x - z * DEPTH_FACTOR,
    y: y + z * HEIGHT_FACTOR
  };
}
```

### Polygon-Punkte für Parallelogramme
Für ein Feld auf der oberen Seite an Position (row, col):

```javascript
function getTopFaceFieldPoints(baseX, baseY, row, col, fieldSize) {
  const x = baseX + col * fieldSize;
  const y = baseY + row * fieldSize;
  const z = fieldSize;

  // 4 Eckpunkte des Parallelogramms
  const p1 = projectTop(x, y, 0);
  const p2 = projectTop(x + fieldSize, y, 0);
  const p3 = projectTop(x + fieldSize, y, z);
  const p4 = projectTop(x, y, z);

  return `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y} ${p4.x},${p4.y}`;
}
```

## Qualitätssicherung

- [ ] Würfel wird korrekt dargestellt
- [ ] Alle 4 Seiten sind sichtbar (Front, Top, Left, Right)
- [ ] Jede Seite hat 9 Felder (3x3)
- [ ] Alle Felder sind grau
- [ ] Responsive Design funktioniert
- [ ] Code ist sauber und kommentiert
- [ ] GitHub Pages ready (statische Dateien)

## Timeline

1. **Phase 1**: Basis-Implementierung (Würfeldarstellung)
2. **Phase 2**: Styling und Responsive Design
3. **Phase 3**: Testing und Optimierung
4. **Phase 4**: Deployment auf GitHub Pages
5. **Zukünftig**: Perzeptionsaufgaben und Interaktivität

## Offene Fragen

- Soll es später auch andere Ansichten geben (z.B. von hinten)?
- Welche spezifischen Perzeptionsaufgaben sind geplant?
- Gibt es Design-Präferenzen (Farben, Schriften, etc.)?
